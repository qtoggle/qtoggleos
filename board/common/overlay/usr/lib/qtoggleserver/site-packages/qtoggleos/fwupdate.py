
import asyncio
import json
import logging
import re

import psutil

from pathlib import Path

from qtoggleserver import system
from qtoggleserver import version
from qtoggleserver.system import fwupdate


logger = logging.getLogger(__name__)


class FWUpdateCommandError(fwupdate.FWUpdateException):
    pass


class FWUpdateDriver(fwupdate.BaseDriver):
    FWUPDATE_BIN = "/sbin/fwupdate"
    QS_LATEST_VERSION_BIN = "/usr/libexec/qtoggleserver/qs-latest-version"
    HOST_ROOT = "/host"
    DOCKER_COMPOSE_ENV = f"{HOST_ROOT}/data/etc/docker-compose.env"
    FLASH_REBOOT_STARTED_FILE = f"{HOST_ROOT}/data/.fwupdate/flash_reboot_started"
    OS_TRIGGER_FILE = f"{HOST_ROOT}/tmp/os_trigger"

    async def get_current_version(self) -> str:
        return self._join_versions(*(await self._get_current_versions()))

    async def get_latest(self) -> tuple[str, str, str]:
        os_version, os_url, os_date, qs_version, qs_date = await self._get_latest_versions()
        
        version = self._join_versions(os_version, qs_version)
        url = self._join_url(os_url, qs_version)
        date = max(os_date, qs_date)

        return version, date, url

    async def get_status(self) -> str:
        if self._docker_compose_pull_running():
            return fwupdate.STATUS_DOWNLOADING
    
        s = await self._call_fwupdate(["status"])
        if s == "idle":
            status = fwupdate.STATUS_IDLE
        elif re.match("^downloading .*$", s):
            status = fwupdate.STATUS_DOWNLOADING
        elif re.match("^downloaded .*$", s):
            status = fwupdate.STATUS_EXTRACTING
        elif re.match("^extracting .*$", s):
            status = fwupdate.STATUS_EXTRACTING
        elif re.match("^extracted .*$", s):
            status = fwupdate.STATUS_FLASHING
        elif re.match("^flashing boot .*$", s):
            status = fwupdate.STATUS_FLASHING
        elif re.match("^boot flashed .*$", s):
            status = fwupdate.STATUS_RESTARTING
        elif re.match("^rebooting .*$", s):
            status = fwupdate.STATUS_RESTARTING
        else:
            status = fwupdate.STATUS_ERROR

        return status

    async def update_to_version(self, version: str) -> None:
        target_os_version, target_qs_version = self._split_versions(version)
        current_os_version, current_qs_version = await self._get_current_versions()
        
        if target_qs_version != current_qs_version:
            logger.info("starting QS version update from \"%s\" to \"%s\"", current_qs_version, target_qs_version)
            self._docker_compose_env_update(target_qs_version)
            if target_os_version == current_os_version:
                # If OS doesn't need update, pull and reboot manually
                self._docker_compose_trigger_pull()
                await self._wait_docker_compose_pull_running()
                self._fake_fwupdate_reboot()
                asyncio.create_task(self._wait_docker_compose_pull_complete_and_reboot())
                return

        if target_os_version != current_os_version:
            logger.info("starting OS version update from \"%s\" to \"%s\"", current_os_version, target_os_version)
            asyncio.create_task(self._call_fwupdate(["install", target_os_version]))
            await self._wait_not_idle()

    async def update_to_url(self, url):
        target_os_url, target_qs_version = self._split_url(url)
        current_os_version, current_qs_version = await self._get_current_versions()
        
        if target_qs_version != current_qs_version:
            logger.info("starting QS version update from \"%s\" to \"%s\"", current_qs_version, target_qs_version)
            self._docker_compose_env_update(target_qs_version)

        logger.info("starting OS version update to \"%s\"", target_os_url)
        asyncio.create_task(self._call_fwupdate(["install", target_os_url]))
        await self._wait_not_idle()

    async def is_auto_update_enabled(self) -> bool:
        return await self._call_fwupdate(["auto"]) == "on"

    async def set_auto_update_enabled(self, enabled: bool) -> None:
        await self._call_fwupdate(["auto", ["off", "on"][enabled]])

    async def _call_fwupdate(self, args: list[str]) -> str:
        args = ["chroot", self.HOST_ROOT, self.FWUPDATE_BIN] + args
        
        logger.debug("calling \"%s\"", " ".join(args[2:]))

        process = await asyncio.create_subprocess_exec(
           *args,
           stdout=asyncio.subprocess.PIPE,
           stderr=asyncio.subprocess.PIPE
        )
        stdout, stderr = await process.communicate()        
        if process.returncode:
            raise FWUpdateCommandError(stderr.decode())

        return stdout.strip().decode()

    async def _get_qs_latest_version(self) -> str:
        args = ["chroot", self.HOST_ROOT, self.QS_LATEST_VERSION_BIN]
        
        logger.debug("calling \"%s\"", " ".join(args[2:]))

        process = await asyncio.create_subprocess_exec(
           *args,
           stdout=asyncio.subprocess.PIPE,
           stderr=asyncio.subprocess.PIPE
        )
        stdout, stderr = await process.communicate()        
        if process.returncode:
            raise FWUpdateCommandError(stderr.decode())

        return stdout.strip().decode()

    async def _get_current_versions(self) -> tuple[str, str]:
        os_version = await self._call_fwupdate(["current"])
        qs_version = version.VERSION

        return os_version, qs_version

    async def _get_latest_versions(self) -> tuple[str, str, str, str, str]:
        os_versions = await self._call_fwupdate(["latest"])
        qs_versions = await self._get_qs_latest_version()
        if not os_versions:
            raise fwupdate.FWUpdateException("Failed to get latest OS version")
        if not qs_versions:
            raise fwupdate.FWUpdateException("Failed to get latest QS version")

        os_version, os_url, os_date = os_versions.split()
        qs_version, qs_date = qs_versions.split()
        
        return os_version, os_url, os_date, qs_version, qs_date
    
    def _join_versions(self, os_version: str, qs_version: str) -> str:
        return f"{os_version}.{qs_version}"

    def _split_versions(self, version: str) -> tuple[str, str]:
        # e.g. `1.2b3.3.14.15b2`
        #      `1.2b2` - OS version
        #      `3.14.15b2` - QS version, always 3 parts
        parts = version.split(".")
        if len(parts) < 4:
            raise fwupdate.FWUpdateException(f"Invalid version: {version}")
        os_version = ".".join(parts[:-3])
        qs_version = ".".join(parts[-3:])
        
        return os_version, qs_version

    def _join_url(self, os_url: str, qs_version: str) -> str:
        return f"{os_url}#{qs_version}"

    def _split_url(self, url: str) -> tuple[str, str]:
        parts = url.split("#", 1)
        if len(parts) != 2:
            raise fwupdate.FWUpdateException(f"Invalid URL: {url}")
        os_url, qs_version = parts
        
        return os_url, qs_version

    async def _wait_not_idle(self) -> None:
        # Wait 2 seconds for verification and download start
        await asyncio.sleep(2)
        
        # Wait at most another 3 seconds for status to become non-idle
        for _ in range(3):
            output = await self._call_fwupdate(["status"])
            if output.startswith("error:"):
                raise FWUpdateCommandError(output[6:].strip())
            if output != "idle":
                break
            await asyncio.sleep(1)
        else:
            raise FWUpdateCommandError("timeout waiting for update to begin")
    
    def _docker_compose_env_update(self, qs_version: str) -> None:
        try:
            with open(self.DOCKER_COMPOSE_ENV, "rt") as f:
                data = f.read()
        except FileNotFoundError:
            data = ""

        if re.search(f"QTOGGLESERVER_VERSION=.*\n", data):
            data = re.sub(r"QTOGGLESERVER_VERSION=.*\n", f"QTOGGLESERVER_VERSION={qs_version}\n", data)
        else:
            data += f"QTOGGLESERVER_VERSION={qs_version}\n"
        with open(self.DOCKER_COMPOSE_ENV, "wt") as f:
            f.write(data)

    def _docker_compose_trigger_pull(self) -> None:
        logger.debug("triggering OS compose-pull")
        with open(self.OS_TRIGGER_FILE, "wt") as f:
            f.write("compose-pull\n")

    def _docker_compose_pull_running(self) -> bool:
        return any(
            cmdline
            for cmdline in (
                " ".join(p.cmdline())
                for p in psutil.process_iter(["cmdline"])
                if p.status != psutil.STATUS_ZOMBIE
            )
            if re.match("^.*docker.*compose.*pull$", cmdline)
        )

    async def _wait_docker_compose_pull_running(self) -> None:
        # Wait 5 seconds for docker compose pull to start
        for _ in range(5):
            if self._docker_compose_pull_running():
                break
            await asyncio.sleep(1)
        else:
            raise FWUpdateCommandError("timeout waiting for docker compose pull to begin")

    async def _wait_docker_compose_pull_complete_and_reboot(self) -> None:
        logger.info("waiting for docker compose pull to complete")
        while True:
            if not self._docker_compose_pull_running():
                break
            logger.debug("docker compose pull still running")
            await asyncio.sleep(2)

        logger.info("docker compose pull completed, rebooting")
        system.reboot()

    def _fake_fwupdate_reboot(self) -> None:
        Path(self.FLASH_REBOOT_STARTED_FILE).parent.mkdir(parents=True, exist_ok=True)
        Path(self.FLASH_REBOOT_STARTED_FILE).touch()

